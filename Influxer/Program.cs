//Copyright -  Adarsha@AdysTech
//https://github.com/AdysTech/Influxer/blob/master/Influxer/Program.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading.Tasks;
using System.Net.Http;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Globalization;
using System.Net.Http.Headers;
using AdysTech.InfluxDB.Client.Net;

namespace AdysTech.Influxer
{
    class Program
    {
        enum Filters
        {
            None,
            Measurement,
            Field,
            Columns
        }

        enum FileFormats
        {
            Perfmon,
            Generic
        }

        const string InfluxUrlSwitch = "-influx";
        const string InfluxDBSwitch = "-dbname";
        const string TagsSwitch = "-tags";
        const string InputFileNameSwitch = "-input";
        const string ColumnSeperatorSwitch = "-seperator";
        const string DateTimeFormatSwitch = "-timeformat";
        const string InfluxUserNameSwitch = "-uname";
        const string InfluxPwdSwitch = "-pass";
        const string FileFormatSwitch = "-format";
        const string TableNameSwitch = "-table";
        const string FilterSwitch = "-filter";
        const string ColumnsSwitch = "-columns";
        const string UtcOffsetSwitch = "-utcoffset";
        const string TimePrecisionSwitch = "-precision";


        private static string influxUrl;
        private static string influxDBName;
        private static string influxDBUserName;
        private static string influxDBPassword;
        private static string tags;
        private static string inputFileName;
        private static char seperator = ',';
        private static string timeFormat = "MM/dd/yyyy HH:mm:ss.fff";
        private static FileFormats fileFormat;
        private static string tableName;
        private static Regex pattern;
        private static Filters filter;
        private static string filteredColumns;
        private static int utcOffsetMin = 0;
        private static TimePrecision timePrecision;

        private static char[] influxIdentifiers = new char[] { ' ', ';', '_', '(', ')', '%', '#', '.', '/', '[', ']', '{', '}', '"' };
        private static char[] whiteSpace = new char[] { '_' };


        enum ExitCode : int
        {
            Success = 0,
            InvalidArgument = 1,
            InvalidFilename = 2,
            UnableToProcess = 3,
            ProcessedWithErrors = 4,
            UnknownError = 10
        }

        static int Main(string[] args)
        {
            #region Command Line argument processing
            if ( args.Contains ("--help") )
            {
                Console.WriteLine ("Valid switches are");
                Console.WriteLine ("-influx <url>       :   Influx DB Url");
                Console.WriteLine ("-dbName <name>      :   Influx DB Name (will be created if not exists)");
                Console.WriteLine ("-uname <username>   :   Influx DB User name");
                Console.WriteLine ("-pass <password>    :   Influx DB Password");
                Console.WriteLine ("-tags <tags>        :   Tags to be passed with every value, key value pairs, space will be converted to _");
                Console.WriteLine ("-input <filename>   :   Input File CSV generated by PerfMon");
                Console.WriteLine ("-seperator <char>   :   Column Seperators default is ,");
                Console.WriteLine ("-timeformat <format>:   Timeformat used by PerfMon (default MM/dd/yyyy hh:mm:ss.fff)");
                Console.WriteLine ("-format <format>    :   CSV File format PerfMon(default) and Generic are supported. For generic TableName is required");
                Console.WriteLine ("-table <table name> :   Influx Table name needed for generic fomat only");
                Console.WriteLine ("-filter <filter>    :   supported:measurement, field, columns.");
                Console.WriteLine ("-columns <columns>  :   Comma seperated list of columns from input files");
                Console.WriteLine ("-utcoffset          :   supported:measurement, field, columns.Offset in minutes to UTC. Applicable to Generic format only");
                Console.WriteLine ("-precision          :   supported:Hours<1>,Minutes<2>,Seconds<3>,MilliSeconds<4>,MicroSeconds<5>,NanoSeconds<6>");

                Console.WriteLine ("-filter-measurement or field is to restrict the input file to only measurements or fileds that already present in the database");
                Console.WriteLine ("-filter-columns is to restrict to only few columns from the input irrespective of existing data in database");
                Console.WriteLine ("-columns will be ignored in other cases. Replace any inline commas in columns names with a space!");
                return (int)ExitCode.Success;
            }

            if ( args.Length == 0 || args.Length % 2 != 0 )
            {
                Console.WriteLine ("Command line arguments not valid, try --help to see valid ones!");
                return (int) ExitCode.InvalidArgument;
            }

            Dictionary<string, string> cmdArgs = new Dictionary<string, string> ();
            for ( int i = 0; i < args.Length; i += 2 )
            {
                cmdArgs.Add (args[i].ToLower (), args[i + 1]);
            }



            if ( cmdArgs.ContainsKey (InfluxUrlSwitch) )
                influxUrl = cmdArgs[InfluxUrlSwitch];
            else
                throw new Exception ("Influx DB Url is a must!!");


            if ( cmdArgs.ContainsKey (InfluxDBSwitch) )
                influxDBName = cmdArgs[InfluxDBSwitch];
            else
                throw new Exception ("Influx DB name is a must!!");

            if ( cmdArgs.ContainsKey (TagsSwitch) )
                tags = cmdArgs[TagsSwitch].Replace (' ', '_');

            if ( cmdArgs.ContainsKey (TableNameSwitch) )
                tableName = cmdArgs[TableNameSwitch];

            if ( cmdArgs.ContainsKey (InputFileNameSwitch) )
            {
                try
                {
                    inputFileName = Path.GetFullPath (cmdArgs[InputFileNameSwitch]);
                }
                catch ( Exception e )
                {
                    Console.Error.WriteLine ("Error with report file:{0},{1}", e.GetType ().Name, e.Message);
                }
            }
            else
                throw new Exception ("Input File Name is a must");

            if ( cmdArgs.ContainsKey (ColumnSeperatorSwitch) )
                seperator = cmdArgs[ColumnSeperatorSwitch][0];
            pattern = new Regex (seperator + "(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)", RegexOptions.Compiled);

            if ( cmdArgs.ContainsKey (DateTimeFormatSwitch) )
                timeFormat = cmdArgs[DateTimeFormatSwitch];

            if ( cmdArgs.ContainsKey (InfluxUserNameSwitch) )
                influxDBUserName = cmdArgs[InfluxUserNameSwitch];

            if ( cmdArgs.ContainsKey (InfluxPwdSwitch) )
                influxDBPassword = cmdArgs[InfluxPwdSwitch];

            if ( cmdArgs.ContainsKey (FileFormatSwitch) )
            {
                if ( !Enum.TryParse<FileFormats> (cmdArgs[FileFormatSwitch], true, out fileFormat) || !Enum.IsDefined (typeof (FileFormats), fileFormat) )
                {
                    Console.WriteLine ("Not supported format {0}!!", cmdArgs[FileFormatSwitch]);
                    return (int) ExitCode.InvalidArgument;
                }
            }
            else
            {
                fileFormat = FileFormats.Perfmon;
            }

            if ( cmdArgs.ContainsKey (FilterSwitch) )
            {
                if ( !Enum.TryParse<Filters> (cmdArgs[FilterSwitch], true, out filter) || !Enum.IsDefined (typeof (Filters), filter) )
                {
                    Console.WriteLine ("Not supported filter:{0}!!", cmdArgs[FilterSwitch]);
                    return (int) ExitCode.InvalidArgument;
                }
            }
            else
            {
                filter = Filters.None;
            }

            if ( cmdArgs.ContainsKey (ColumnsSwitch) )
            {
                if ( filter != Filters.Columns )
                {
                    Console.WriteLine ("Column filtering is supported only with -filter Columns!!");
                    return (int) ExitCode.InvalidArgument;
                }
                if ( String.IsNullOrWhiteSpace (cmdArgs[ColumnsSwitch]) )
                {
                    Console.WriteLine ("Invalid Column filter!!");
                    return (int) ExitCode.InvalidArgument;
                }

                filteredColumns = cmdArgs[ColumnsSwitch];

                try
                {
                    if ( ( fileFormat == FileFormats.Perfmon && ParsePerfMonFileHeader (filteredColumns, false).Count == 0 ) ||
                        ( fileFormat == FileFormats.Generic && ParseGenericColumns (filteredColumns).Count == 0 ) )
                    {
                        Console.WriteLine ("No columns filtered!!");
                        return (int) ExitCode.InvalidArgument;
                    }
                }
                catch ( Exception e )
                {
                    Console.WriteLine ("Unable to parse column filters");
                    return (int) ExitCode.InvalidArgument;
                }
            }

            if ( cmdArgs.ContainsKey (UtcOffsetSwitch) )
            {
                utcOffsetMin = int.Parse (cmdArgs[UtcOffsetSwitch]);
            }

            if ( cmdArgs.ContainsKey (TimePrecisionSwitch) )
            {
                if ( !Enum.TryParse<TimePrecision> (cmdArgs[TimePrecisionSwitch], true, out timePrecision) || !Enum.IsDefined (typeof (TimePrecision), timePrecision) )
                {
                    Console.WriteLine ("Not supported format {0}!!", cmdArgs[TimePrecisionSwitch]);
                    return (int) ExitCode.InvalidArgument;
                }
            }
            else
            {
                timePrecision = TimePrecision.Seconds;
            }

            #endregion
            ExitCode result = ExitCode.UnknownError;
            try
            {
                Stopwatch stopwatch = new Stopwatch ();
                stopwatch.Start ();

                var client = new InfluxDBClient (influxUrl, influxDBUserName, influxDBPassword);

                if ( !VerifyDatabaseAsync (client, influxDBName).Result )
                {
                    Console.WriteLine ("Unable to create DB {0}", influxDBName);
                    return (int) ExitCode.UnableToProcess;
                }
                switch ( fileFormat )
                {
                    case FileFormats.Perfmon:
                        result = ProcessPerfMonLog (inputFileName, client).Result;
                        break;
                    case FileFormats.Generic:
                        if ( String.IsNullOrWhiteSpace (tableName) )
                            throw new ArgumentException ("Generic format needs TableName input");
                        result = ProcessGenericFile (inputFileName, tableName, client).Result;
                        break;
                }

                stopwatch.Stop ();
                Console.WriteLine ("\n Finished!! Processed in {0}", stopwatch.Elapsed.ToString ());

            }

            catch ( AggregateException e )
            {
                Console.Error.WriteLine ("Error!! {0}:{1} - {2}", e.InnerException.GetType ().Name, e.InnerException.Message, e.InnerException.StackTrace);
            }

            catch ( Exception e )
            {
                Console.Error.WriteLine ("Error!! {0}:{1} - {2}", e.GetType ().Name, e.Message, e.StackTrace);
            }
            return (int) result;
        }

        private static async Task<bool> VerifyDatabaseAsync(InfluxDBClient client, string DBName)
        {
            try
            {
                //verify DB exists, create if not
                var dbNames = await client.GetInfluxDBNamesAsync ();
                if ( dbNames.Contains (DBName) )
                    return true;
                else
                {
                    if ( filter == Filters.Measurement || filter == Filters.Field )
                    {
                        Console.WriteLine ("Measurement/Field filtering is not applicable for new database!!");
                        filter = Filters.None;
                    }
                    return await client.CreateDatabaseAsync (DBName);
                }
            }
            catch ( Exception e )
            {
                Console.WriteLine ("Unexpected exception of type {0} caught: {1}",
                            e.GetType (), e.Message);
            }
            return false;
        }


        private static async Task<ExitCode> ProcessPerfMonLog(string InputFileName, InfluxDBClient client)
        {

            try
            {
                int minOffset = 0;
                var lineCount = 0;
                var failedCount = 0;
                StringBuilder content = new StringBuilder ();
                var failureReasons = new Dictionary<Type, FailureTracker> ();

                Stopwatch stopwatch = new Stopwatch ();
                stopwatch.Start ();


                var firstLine = File.ReadLines (InputFileName).FirstOrDefault ();

                var firstCol = firstLine.Substring (0, firstLine.IndexOf (','));
                if ( !firstCol.Contains ("PDH-CSV") )
                    throw new Exception ("Input file is not a Standard Perfmon csv file");
                var x = Regex.Matches (firstCol, "([-0-9]+)");
                if ( x.Count > 0 )
                    minOffset = int.Parse (x[3].ToString ());

                //get the column headers
                List<PerfmonCounter> pecrfCounters;
                try
                {
                    pecrfCounters = ParsePerfMonFileHeader (firstLine);
                }
                catch ( Exception ex )
                {
                    throw new InvalidDataException ("Unable to parse file headers", ex);
                }

                var filterColumns = ParsePerfMonFileHeader (filteredColumns, false);

                Dictionary<string, List<string>> dbStructure;
                IEnumerable<IGrouping<string, PerfmonCounter>> perfGroup;
                if ( filter != Filters.None )
                {
                    dbStructure = await client.GetInfluxDBStructureAsync (influxDBName);
                    perfGroup = FilterPerfmonLogColumns (pecrfCounters, filterColumns, dbStructure).GroupBy (p => p.PerformanceObject);
                }
                else
                {
                    perfGroup = pecrfCounters.GroupBy (p => p.PerformanceObject);
                }

                //Parallel.ForEach (File.ReadLines (inputFileName).Skip (1), (string line) =>
                foreach ( var line in File.ReadLines (InputFileName).Skip (1) )
                {
                    lineCount++;
                    try
                    {
                        if ( !await ProcessPerfmonLogLine (line, perfGroup, minOffset, pattern, client) )
                            failedCount++;

                    }
                    catch ( Exception e )
                    {
                        failedCount++;
                        var type = e.GetType ();
                        if ( !failureReasons.ContainsKey (type) )
                            failureReasons.Add (type, new FailureTracker () { ExceptionType = type, Message = e.Message });
                        failureReasons[type].LineNumbers.Add (lineCount);
                    }

                    if ( failedCount > 0 )
                        Console.Write ("\r{0} Processed {1}, Failed - {2}                        ", stopwatch.Elapsed.ToString (@"hh\:mm\:ss"), lineCount, failedCount);
                    else
                        Console.Write ("\r{0} Processed {1}                          ", stopwatch.Elapsed.ToString (@"hh\:mm\:ss"), lineCount);

                }
                lineCount = 0;
                pecrfCounters.Clear ();
                stopwatch.Stop ();
                if ( failedCount > 0 )
                {
                    Console.WriteLine ("\n Done!! Processed {0}, failed to insert {1}", lineCount, failedCount);
                    foreach ( var f in failureReasons.Values )
                        Console.WriteLine ("{0}:{1} - {2} : {3}", f.ExceptionType, f.Message, f.Count, String.Join (",", f.LineNumbers));
                    if ( failedCount == lineCount )
                        return ExitCode.UnableToProcess;
                    else
                        return ExitCode.ProcessedWithErrors;
                }
            }
            catch ( Exception e )
            {
                Console.Error.WriteLine ("\r\nError!! {0}:{1} - {2}", e.GetType ().Name, e.Message, e.StackTrace);
                return ExitCode.UnknownError;
            }
            return ExitCode.Success;
        }

        private static List<PerfmonCounter> ParsePerfMonFileHeader(string headerLine, bool quoted = true)
        {
            List<PerfmonCounter> perfCounters = new List<PerfmonCounter> ();
            if ( String.IsNullOrWhiteSpace (headerLine) ) return perfCounters;
            var columns = pattern.Split (headerLine);
            var column = 1;

            perfCounters.AddRange (columns.Skip (quoted ? 1 : 0).Where (s => quoted ? s.StartsWith ("\"\\") : s.StartsWith ("\\")).Select (p =>
                    p.Replace (influxIdentifiers, "_").Split ('\\')).Select (p =>
                        new PerfmonCounter ()
                        {
                            ColumnIndex = column++,
                            Host = p[2].Trim (whiteSpace),
                            PerformanceObject = p[3].Trim (whiteSpace),
                            CounterName = p[4].Trim (whiteSpace)
                        }));
            return perfCounters;
        }

        private static List<PerfmonCounter> FilterPerfmonLogColumns(List<PerfmonCounter> columns, List<PerfmonCounter> filterColumns, Dictionary<string, List<string>> dbStructure)
        {
            switch ( filter )
            {
                case Filters.Measurement:
                    return columns.Where (p => dbStructure.ContainsKey (p.PerformanceObject)).ToList ();
                case Filters.Field:
                    return columns.Where (p => dbStructure.ContainsKey (p.PerformanceObject) && dbStructure[p.PerformanceObject].Contains (p.CounterName)).ToList ();
                case Filters.Columns:
                    return columns.Where (p => filterColumns.Any (f => p.PerformanceObject == f.PerformanceObject && p.CounterName == f.CounterName)).ToList ();
            }
            return columns;
        }

        private static async Task<bool> ProcessPerfmonLogLine(string line, IEnumerable<IGrouping<string, PerfmonCounter>> perfGroup, int minOffset, Regex pattern, InfluxDBClient client)
        {
            StringBuilder content = new StringBuilder ();
            DateTime timeStamp;

            var columns = pattern.Split (line.Replace ("\"", ""));
            var columnCount = columns.Count ();

            if ( !DateTime.TryParseExact (columns[0], timeFormat, CultureInfo.InvariantCulture, DateTimeStyles.None, out timeStamp) )
                throw new FormatException ("Couldn't parse " + columns[0] + " using format " + timeFormat + ", check -timeformat argument");
            var epoch = timeStamp.AddMinutes (minOffset).ToEpoch (timePrecision);

            double value = 0.0;
            content.Clear ();
            var lineStartIndex = 0;

            foreach ( var group in perfGroup )
            {
                foreach ( var hostGrp in group.GroupBy (p => p.Host) )
                {
                    lineStartIndex = content.Length;
                    content.AppendFormat ("{0},Host={1}", group.Key, hostGrp.Key);

                    if ( tags != null )
                        content.AppendFormat (",{0} ", tags);
                    else
                        content.Append (" ");

                    var useCounter = false;

                    foreach ( var counter in hostGrp )
                    {
                        if ( !String.IsNullOrWhiteSpace (columns[counter.ColumnIndex]) && Double.TryParse (columns[counter.ColumnIndex], out value) )
                        {
                            content.AppendFormat ("{0}={1:0.00},", counter.CounterName, value);
                            useCounter = true;

                        }
                    }

                    if ( useCounter )
                        content.AppendFormat (" {0}\n", epoch);
                    else
                    {
                        content.Length = lineStartIndex;
                    }
                }
            }

            //each group will have an ending comma which is not needed
            content.Replace (", ", " ");
            //remove last \n
            content.Remove (content.Length - 1, 1);
            //synchronous processing
            if ( await client.PostRawValueAsync (influxDBName, TimePrecision.Seconds, content.ToString ()) )
                return true;
            else
            {
                return false;
            }

        }

        private static async Task<ExitCode> ProcessGenericFile(string InputFileName, string tableName, InfluxDBClient client)
        {
            try
            {
                StringBuilder content = new StringBuilder ();
                var lineCount = 0;
                var failedCount = 0;
                Stopwatch stopwatch = new Stopwatch ();
                stopwatch.Start ();

                List<GenericColumn> columnHeaders;

                var firstLine = File.ReadLines (InputFileName).FirstOrDefault ();
                columnHeaders = ParseGenericColumns (firstLine);

                Dictionary<string, List<string>> dbStructure;
                if ( filter != Filters.None )
                {
                    var filterColumns = ParseGenericColumns (filteredColumns);

                    dbStructure = await client.GetInfluxDBStructureAsync (influxDBName);
                    columnHeaders = FilterGenericColumns (columnHeaders, filterColumns, dbStructure);

                }

                var failureReasons = new Dictionary<Type, FailureTracker> ();


                //Parallel.ForEach (File.ReadLines (inputFileName).Skip (1), (string line) =>
                foreach ( var line in File.ReadLines (InputFileName).Skip (1) )
                {
                    try
                    {
                        if ( !await ProcessGenericLine (line, columnHeaders, pattern, client) )
                            failedCount++;
                    }
                    catch ( Exception e )
                    {
                        failedCount++;
                        var type = e.GetType ();
                        if ( !failureReasons.ContainsKey (type) )
                            failureReasons.Add (type, new FailureTracker () { ExceptionType = type, Message = e.Message });
                        failureReasons[type].LineNumbers.Add (lineCount);
                    }

                    lineCount++;

                    if ( failedCount > 0 )
                        Console.Write ("\r{0} Processed {1}, Failed - {2}                        ", stopwatch.Elapsed.ToString (@"hh\:mm\:ss"), lineCount, failedCount);
                    else
                        Console.Write ("\r{0} Processed {1}                          ", stopwatch.Elapsed.ToString (@"hh\:mm\:ss"), lineCount);

                }
                lineCount = 0;

                stopwatch.Stop ();
                if ( failedCount > 0 )
                {
                    Console.WriteLine ("\n Done!! Processed {0}, failed to insert {1}", lineCount, failedCount);
                    foreach ( var f in failureReasons.Values )
                        Console.WriteLine ("{0}:{1} - {2} : {3}", f.ExceptionType, f.Message, f.Count, String.Join (",", f.LineNumbers));
                    if ( failedCount == lineCount )
                        return ExitCode.UnableToProcess;
                    else
                        return ExitCode.ProcessedWithErrors;
                }

            }
            catch ( Exception e )
            {
                Console.Error.WriteLine ("\r\nError!! {0}:{1} - {2}", e.GetType ().Name, e.Message, e.StackTrace);
                return ExitCode.UnknownError;
            }
            return ExitCode.Success;
        }

        private static List<GenericColumn> ParseGenericColumns(string headerLine)
        {
            var columns = new List<GenericColumn> ();
            int index = 0;
            columns.AddRange (pattern.Split (headerLine).Select (s => new GenericColumn () { ColumnIndex = index++, ColumnHeader = s.Replace (influxIdentifiers, "_") }));
            return columns;
        }

        private static List<GenericColumn> FilterGenericColumns(List<GenericColumn> columns, List<GenericColumn> filterColumns, Dictionary<string, List<string>> dbStructure)
        {
            switch ( filter )
            {
                case Filters.Measurement:
                    return columns.Where (p => dbStructure.ContainsKey (tableName)).ToList ();
                case Filters.Field:
                    return columns.Where (p => dbStructure.ContainsKey (tableName) && dbStructure[tableName].Contains (p.ColumnHeader)).ToList ();
                case Filters.Columns:
                    return columns.Where (p => filterColumns.Any (f => f.ColumnHeader == p.ColumnHeader)).ToList ();
            }
            return columns;
        }

        private async static Task<bool> ProcessGenericLine(string line, List<GenericColumn> columnHeaders, Regex pattern, InfluxDBClient client)
        {
            Dictionary<string, double> values = new Dictionary<string, double> ();
            StringBuilder tagsCollection = new StringBuilder ();

            DateTime timeStamp;

            var columns = pattern.Split (line.Replace ("\"", ""));
            var columnCount = columns.Count ();

            if ( !DateTime.TryParseExact (columns[0], timeFormat, CultureInfo.InvariantCulture, DateTimeStyles.None, out timeStamp) )
                throw new FormatException ("Couldn't parse " + columns[0] + " using format " + timeFormat + ", check -timeformat argument");
            var epoch = timeStamp.AddMinutes (utcOffsetMin).ToEpoch (timePrecision);

            double value = 0.0;

            foreach ( var c in columnHeaders.Skip (1) )
            {
                if ( Double.TryParse (columns[c.ColumnIndex], out value) )
                {
                    values.Add (c.ColumnHeader, Math.Round (value, 2));
                    //break;
                }
                else
                    tagsCollection.AppendFormat ("{0}={1},", c.ColumnHeader, columns[c.ColumnIndex].Replace (influxIdentifiers, "_"));
            }

            if ( tags != null )
                tagsCollection.Append (tags);
            else
                tagsCollection.Remove (tagsCollection.Length - 1, 1);

            if ( await client.PostValuesAsync (influxDBName, tableName, epoch, timePrecision, tagsCollection.ToString (), values) )
                return true;
            else
            {
                return false;
            }

        }
    }
}
