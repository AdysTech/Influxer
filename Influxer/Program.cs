//Copyright -  Adarsha@AdysTech
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading.Tasks;
using System.Net.Http;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Globalization;
using System.Net.Http.Headers;

namespace AdysTech.Influxer
{
    class Program
    {
        const string InfluxUrlSwitch = "-influx";
        const string InfluxDBSwitch = "-dbname";
        const string TagsSwitch = "-tags";
        const string InputFileNameSwitch = "-input";
        const string ColumnSeperatorSwitch = "-seperator";
        const string DateTimeFormatSwitch = "-timeformat";
        const string InfluxUserNameSwitch = "-uname";
        const string InfluxPwdSwitch = "-pass";

        private static string influxUrl;
        private static string influxDB;
        private static string influxDBUserName;
        private static string influxDBPassword;
        private static string tags;
        private static string inputFileName;
        private static char seperator = ',';
        private static string timeFormat = "MM/dd/yyyy HH:mm:ss.fff";


        static void Main(string[] args)
        {
            #region Command Line argument processing
            if ( args.Contains ("--help") )
            {
                Console.WriteLine ("Valid switches are");
                Console.WriteLine ("Influx DB Url:  -influx <url>");
                Console.WriteLine ("Influx DB Name (must be created already, or use -create true switch):  -dbName <name>");
                Console.WriteLine ("Influx DB User name:  -uname <username>");
                Console.WriteLine ("Influx DB Password:  -pass <password>");
                Console.WriteLine ("Tags to be passed with every value:  -tags <tags> these will be passed as is");
                Console.WriteLine ("Input File CSV generated by PerfMon:  -input <filename>");
                Console.WriteLine ("Column Seperators default is , :  -seperator<seperator>");
                Console.WriteLine ("Timeformat used by PerfMon (default MM/dd/yyyy hh:mm:ss.fff:  -timeformat <format>");
                return;
            }

            if ( args.Length == 0 || args.Length % 2 != 0 )
            {
                throw new ArgumentException ("Command line arguments not valid, try --help to see valid ones!");
            }

            Dictionary<string, string> cmdArgs = new Dictionary<string, string> ();
            for ( int i = 0; i < args.Length; i += 2 )
            {
                cmdArgs.Add (args[i].ToLower (), args[i + 1]);
            }



            if ( cmdArgs.ContainsKey (InfluxUrlSwitch) )
                influxUrl = cmdArgs[InfluxUrlSwitch];
            else
                throw new Exception ("Influx DB Url is a must!!");


            if ( cmdArgs.ContainsKey (InfluxDBSwitch) )
                influxDB = cmdArgs[InfluxDBSwitch];
            else
                throw new Exception ("Influx DB name is a must!!");

            if ( cmdArgs.ContainsKey (TagsSwitch) )
                tags = cmdArgs[TagsSwitch];


            if ( cmdArgs.ContainsKey (InputFileNameSwitch) )
            {
                try
                {
                    inputFileName = Path.GetFullPath (cmdArgs[InputFileNameSwitch]);
                }
                catch ( Exception e )
                {
                    Console.WriteLine ("Error with report file:{0},{1}", e.GetType ().Name, e.Message);
                }
            }
            else
                throw new Exception ("Input File Name is a must");

            if ( cmdArgs.ContainsKey (ColumnSeperatorSwitch) )
                seperator = cmdArgs[ColumnSeperatorSwitch][0];

            if ( cmdArgs.ContainsKey (DateTimeFormatSwitch) )
                timeFormat = cmdArgs[DateTimeFormatSwitch];
            //if (!timeFormat.StartsWith("\""))
            //    timeFormat = "\"" + timeFormat;
            //if (!timeFormat.EndsWith("\""))
            //    timeFormat = timeFormat + "\"";

            if ( cmdArgs.ContainsKey (InfluxUserNameSwitch) )
                influxDBUserName = cmdArgs[InfluxUserNameSwitch];

            if ( cmdArgs.ContainsKey (InfluxPwdSwitch) )
                influxDBPassword = cmdArgs[InfluxPwdSwitch];

            #endregion
            try
            {
                if ( InfluxerAsync ().Result )
                    Console.WriteLine ("Finished!!");
            }
            catch ( AggregateException e )
            {
                Console.WriteLine (e.InnerException.Message);
                Debug.WriteLine (e.InnerException.Message);
            }
        }

        private static async Task<bool> InfluxerAsync()
        {
            var influxAddress = new Uri (influxUrl + "/query?");

            try
            {
                int minOffset = 0;
                var lineCount = 0;
                var failedCount = 0;
                StringBuilder content = new StringBuilder ();

                Regex pattern = new Regex (seperator + "(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)", RegexOptions.Compiled);

                Stopwatch stopwatch = new Stopwatch ();
                stopwatch.Start ();

                HttpClientHandler handler = new HttpClientHandler ();
                handler.UseDefaultCredentials = true;
                handler.PreAuthenticate = true;
                handler.Proxy = WebRequest.DefaultWebProxy;
                WebRequest.DefaultWebProxy.Credentials = CredentialCache.DefaultNetworkCredentials;

                var client = new HttpClient (handler);

                client.BaseAddress = influxAddress;
                client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue ("Basic", Convert.ToBase64String (System.Text.ASCIIEncoding.ASCII.GetBytes (string.Format ("{0}:{1}", influxDBUserName, influxDBPassword))));


                //verify DB exists, create if not
                var dbNames = await GetInfluxDBNamesAsync (client);

                influxAddress = new Uri (influxUrl + "/write?db=" + influxDB + "&precision=s");
                List<PerfmonCounter> pecrfCounters = new List<PerfmonCounter> ();
                IEnumerable<IGrouping<string, PerfmonCounter>> perfGourp = null;


                var firstLine = File.ReadLines (inputFileName).FirstOrDefault ();
                var columns = pattern.Split (firstLine.Replace ("\"", ""));

                if ( !columns[0].Contains ("PDH-CSV") )
                    throw new Exception ("Input file is not a Standard Perfmon csv file");
                var x = Regex.Matches (columns[0], "([-0-9]+)");
                if ( x.Count > 0 )
                    minOffset = int.Parse (x[3].ToString ());
                //get the column headers
                var column = 1;
                pecrfCounters.AddRange (columns.Skip (1).Where (s => s.StartsWith ("\\")).Select (p => p.Replace (' ', '_').Split ('\\')).Select (p => new PerfmonCounter () { ColumnIndex = column++, Host = p[2], PerformanceObject = p[3], CounterName = p[4] }));
                perfGourp = pecrfCounters.GroupBy (p => p.PerformanceObject);


                foreach ( var line in File.ReadLines (inputFileName).Skip (1) )
                {
                    try
                    {
                        if ( await ProcessLine (line, perfGourp, minOffset, pattern, client) )
                        {
                            lineCount++;
                            Console.Write ("\r Processed {0}                          ", lineCount);
                        }
                        else
                        {
                            failedCount++; lineCount++;
                            Console.Write ("\r Processed {0}, Failed - {1}                        ", lineCount, failedCount);
                        }
                    }
                    catch ( Exception e )
                    {
                        Console.WriteLine (e.InnerException.Message);
                        Debug.WriteLine (e.InnerException.Message);
                        break;
                    }
                }

                //Parallel.ForEach (File.ReadLines (inputFileName).Skip (1), (string line) =>
                //{
                //    if ( ProcessLine (line, perfGourp, minOffset, pattern, client).Result )
                //    {
                //        lineCount++;
                //        Console.Write ("\r Processed {0}                          ", lineCount);
                //    }
                //    else
                //    {
                //        failedCount++; lineCount++;
                //        Console.Write ("\r Processed {0}, Failed - {1}                        ", lineCount, failedCount);
                //    }
                //});

                stopwatch.Stop ();
                Debug.WriteLine ("Done Async Processing, Time elapsed: {0}", stopwatch.Elapsed);

                lineCount = 0;
                pecrfCounters.Clear ();


                Console.Write ("\n Done!! Processed{0}, failed to insert{1}", lineCount, failedCount);
            }
            catch ( Exception e )
            {   
                Console.WriteLine ("\rError Processing, Exception:{0}", e.Message);
                Debug.WriteLine ("\rError Processing, Exception:{0}", e.Message);
                return false;
            }
            return true;
        }

        private static async Task<bool> ProcessLine(string line, IEnumerable<IGrouping<string, PerfmonCounter>> perfGourp, int minOffset, Regex pattern, HttpClient client)
        {
            StringBuilder content = new StringBuilder ();
            DateTime timeStamp;
            try
            {
                var columns = pattern.Split (line.Replace ("\"", ""));
                var columnCount = columns.Count ();

                if ( !DateTime.TryParseExact (columns[0], timeFormat, CultureInfo.InvariantCulture, DateTimeStyles.None, out timeStamp) )
                    throw new FormatException ("Couldn't parse " + columns[0] + " using format " + timeFormat + ", check -timeformat argument");
                var epoch = timeStamp.AddMinutes (minOffset).ToEpoch ();

                double value = 0.0;
                content.Clear ();
                var lineStartIndex = 0;

                foreach ( var group in perfGourp )
                {
                    foreach ( var hostGrp in group.GroupBy (p => p.Host) )
                    {
                        lineStartIndex = content.Length;
                        content.AppendFormat ("{0},Host={1} ", group.Key, hostGrp.Key);
                        var useCounter = false;
                        foreach ( var counter in hostGrp )
                        {
                            if ( !String.IsNullOrWhiteSpace (columns[counter.ColumnIndex]) && Double.TryParse (columns[counter.ColumnIndex], out value) )
                            {
                                content.AppendFormat ("{0}={1:0.00},", counter.CounterName, value);
                                useCounter = true;
                            }
                        }
                        if ( useCounter )
                            content.AppendFormat (" {0}\n", epoch);
                        else
                        {
                            content.Length = lineStartIndex;
                        }
                    }
                }

                //each group will have an ending comma which is not needed
                content.Replace (", ", " ");
                //remove last \n
                content.Remove (content.Length - 1, 1);
                //synchronous processing
                if ( await PostToInfluxAsync (client, content.ToString ()) )
                    return true;
                else
                {
                    return false;
                }
            }
            catch ( UnauthorizedAccessException e )
            {
                throw e;
            }
            catch ( Exception e )
            {
                Debug.WriteLine (e.Message);
            }
            return false;
        }

        private static async Task<bool> CreateInfluxDBAsync(HttpClient client, string dbName)
        {
            return false;
        }

        private static async Task<List<String>> GetInfluxDBNamesAsync(HttpClient client)
        {
            try
            {
                //FormUrlEncodedContent requestContent = new FormUrlEncodedContent (new[] { new KeyValuePair<string, string> ("q", "SHOW DATABASES") });
                //ByteArrayContent requestContent = new ByteArrayContent (Encoding.UTF8.GetBytes ("q=SHOW DATABASES"));
                StringContent requestContent = new StringContent ("q%3DSHOW+DATABASES");
                HttpResponseMessage response = await client.PostAsync (client.BaseAddress, requestContent);

                if ( response.StatusCode == HttpStatusCode.Unauthorized )
                {

                }
            }
            catch ( HttpRequestException e )
            {
                return null;
            }
            return null;
        }

        private static async Task<bool> PostToInfluxAsync(HttpClient client, string content)
        {
            ByteArrayContent requestContent = new ByteArrayContent (Encoding.UTF8.GetBytes (content));
            try
            {
                HttpResponseMessage response = await client.PostAsync (client.BaseAddress, requestContent);

                if ( response.StatusCode == HttpStatusCode.Unauthorized )
                    throw new UnauthorizedAccessException ("InfluxDB needs credentials");
                //if(response.StatusCode==HttpStatusCode.NotFound)

                else if ( response.StatusCode == HttpStatusCode.NoContent )
                    return true;
                else
                    return false;
            }
            catch ( HttpRequestException e )
            {
                return false;
            }
            catch ( UnauthorizedAccessException e )
            {
                throw e;
            }
            catch ( Exception e )
            {
                return false;
            }

        }
    }
}
