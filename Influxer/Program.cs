//Copyright -  Adarsha@AdysTech
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading.Tasks;
using System.Net.Http;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Globalization;

namespace AdysTech.Influxer
{
    class Program
    {
        const string InfluxUrlSwitch = "-influx";
        const string InfluxDBSwitch = "-dbname";
        const string TagsSwitch = "-tags";
        const string InputFileNameSwitch = "-input";
        const string ColumnSeperatorSwitch = "-seperator";
        const string DateTimeFormatSwitch = "-timeformat";
        private static string influxUrl;
        private static string influxDB;
        private static string tags;
        private static string inputFileName;
        private static char seperator = ',';
        private static string timeFormat = "MM/dd/yyyy HH:mm:ss.fff";

        static void Main(string[] args)
        {
            #region Command Line argument processing
            if ( args.Contains ("--help") )
            {
                Console.WriteLine ("Valid switches are");
                Console.WriteLine ("Influx DB Url:  -influx <url>");
                Console.WriteLine ("Influx DB Name (must be created already, or use -create true switch):  -dbName <name>");
                Console.WriteLine ("Tags to be passed with every value:  -tags <tags> these will be passed as is");
                Console.WriteLine ("Input File CSV generated by PerfMon:  -input <filename>");
                Console.WriteLine ("Column Seperators default is , :  -seperator<seperator>");
                Console.WriteLine ("Timeformat used by PerfMon (default MM/dd/yyyy hh:mm:ss.fff:  -timeformat <format>");
                return;
            }

            if ( args.Length == 0 || args.Length % 2 != 0 )
            {
                throw new ArgumentException ("Command line arguments not valid, try --help to see valid ones!");
            }

            Dictionary<string, string> cmdArgs = new Dictionary<string, string> ();
            for ( int i = 0; i < args.Length; i += 2 )
            {
                cmdArgs.Add (args[i].ToLower (), args[i + 1]);
            }



            if ( cmdArgs.ContainsKey (InfluxUrlSwitch) )
                influxUrl = cmdArgs[InfluxUrlSwitch];
            else
                throw new Exception ("Influx DB Url is a must!!");


            if ( cmdArgs.ContainsKey (InfluxDBSwitch) )
                influxDB = cmdArgs[InfluxDBSwitch];
            else
                throw new Exception ("Influx DB name is a must!!");

            if ( cmdArgs.ContainsKey (TagsSwitch) )
                tags = cmdArgs[TagsSwitch];


            if ( cmdArgs.ContainsKey (InputFileNameSwitch) )
            {
                try
                {
                    inputFileName = Path.GetFullPath (cmdArgs[InputFileNameSwitch]);
                }
                catch ( Exception e )
                {
                    Console.WriteLine ("Error with report file:{0},{1}", e.GetType ().Name, e.Message);
                }
            }
            else
                throw new Exception ("Input File Name is a must");

            if ( cmdArgs.ContainsKey (ColumnSeperatorSwitch) )
                seperator = cmdArgs[ColumnSeperatorSwitch][0];

            if ( cmdArgs.ContainsKey (DateTimeFormatSwitch) )
                timeFormat = cmdArgs[DateTimeFormatSwitch];
            //if (!timeFormat.StartsWith("\""))
            //    timeFormat = "\"" + timeFormat;
            //if (!timeFormat.EndsWith("\""))
            //    timeFormat = timeFormat + "\"";

            #endregion

            var influxAddress = new Uri (influxUrl + "/write?db=" + influxDB + "&precision=s");

            List<PerfmonCounter> perfCounters = new List<PerfmonCounter> ();
            IEnumerable<IGrouping<string, PerfmonCounter>> perfGourp = null;

            int minOffset = 0;
            var lineCount = 0;
            var failedCount = 0;
            StringBuilder content = new StringBuilder ();
            DateTime timeStamp;
            Regex pattern = new Regex (seperator + "(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)", RegexOptions.Compiled);

            try
            {
                Stopwatch stopwatch = new Stopwatch ();
                #region Async Processing
                stopwatch.Start ();
                HttpClientHandler handler = new HttpClientHandler ();
                handler.UseDefaultCredentials = true;
                handler.PreAuthenticate = true;
                //var proxy = WebRequest.GetSystemWebProxy();
                //proxy.Credentials = System.Net.CredentialCache.DefaultCredentials;
                //handler.Proxy = proxy;
                handler.Proxy = WebRequest.DefaultWebProxy;
                WebRequest.DefaultWebProxy.Credentials = CredentialCache.DefaultNetworkCredentials;

                var client = new HttpClient (handler);
                client.BaseAddress = influxAddress;

                var firstLine = File.ReadLines (inputFileName).FirstOrDefault ();
                var columns = pattern.Split (firstLine.Replace ("\"", ""));
                if ( lineCount++ == 0 )
                {
                    if ( !columns[0].Contains ("PDH-CSV") )
                        throw new Exception ("Input file is not a Standard Perfmon csv file");
                    var x = Regex.Matches (columns[0], "([-0-9]+)");
                    if ( x.Count > 0 )
                        minOffset = int.Parse (x[3].ToString ());
                    //get the column headers
                    var column = 1;
                    perfCounters.AddRange (columns.Skip (1).Where (s => s.StartsWith ("\\")).Select (p => p.Replace (' ', '_').Split ('\\')).Select (p => new PerfmonCounter () { ColumnIndex = column++, Host = p[2], PerformanceObject = p[3], CounterName = p[4] }));
                    perfGourp = perfCounters.GroupBy (p => p.PerformanceObject);
                }

                
                //foreach ( var line in File.ReadLines (inputFileName).Skip (1) )
                //{
                //    if ( ProcessLine (line, perfGourp, minOffset, pattern, client).Result )
                //        lineCount++;
                //    else
                //        failedCount++;
                //}
                
                Parallel.ForEach (File.ReadLines (inputFileName).Skip (1), (string line) =>
                {
                    if ( ProcessLine (line, perfGourp, minOffset, pattern, client).Result )
                    {
                        lineCount++;
                        Console.Write ("\r Processed {0}                          ", lineCount);
                    }
                    else
                    {
                        failedCount++; lineCount++;
                        Console.Write ("\r Processed {0}, Failed - {1}                        ", lineCount, failedCount);
                    }
                });

                stopwatch.Stop ();
                Debug.WriteLine ("Done Async Processing, Time elapsed: {0}", stopwatch.Elapsed);
                #endregion

                lineCount = 0;
                perfCounters.Clear ();

                #region Synchronous processing
                //stopwatch.Start();
                //foreach (var line in File.ReadLines(inputFileName))
                //{
                //    try
                //    {
                //        var columns = pattern.Split(line.Replace("\"", ""));
                //        var columnCount = columns.Count();
                //        if (lineCount++ == 0)
                //        {
                //            if (!columns[0].Contains("PDH-CSV"))
                //                throw new Exception("Input file is not a Standard Perfmon csv file");
                //            var x = Regex.Matches(columns[0], "([-0-9]+)");
                //            if (x.Count > 0)
                //                minOffset = int.Parse(x[3].ToString());
                //            //get the column headers
                //            var column = 1;
                //            perfCounters.AddRange(columns.Skip(1).Where(s => s.StartsWith("\\")).Select(p => p.Replace(' ', '_').Split('\\')).Select(p => new PerfmonCounter() { ColumnIndex = column++, Host = p[2], PerformanceObject = p[3], CounterName = p[4] }));
                //            perfGourp = perfCounters.GroupBy(p => p.PerformanceObject);
                //            continue;
                //        }

                //        if (!DateTime.TryParseExact(columns[0], timeFormat, CultureInfo.InvariantCulture, DateTimeStyles.None, out timeStamp))
                //            throw new FormatException("Couldn't parse " + columns[0] + " using format " + timeFormat + ", check -timeformat argument");
                //        var epoch = timeStamp.AddMinutes(minOffset).ToEpoch();

                //        double value = 0.0;
                //        content.Clear();
                //        var lineStartIndex = 0;

                //        foreach (var group in perfGourp)
                //        {
                //            foreach (var hostGrp in group.GroupBy(p => p.Host))
                //            {
                //                lineStartIndex = content.Length;
                //                content.AppendFormat("{0},Host={1} ", group.Key, hostGrp.Key);
                //                var useCounter = false;
                //                foreach (var counter in hostGrp)
                //                {
                //                    if (!String.IsNullOrWhiteSpace(columns[counter.ColumnIndex]) && Double.TryParse(columns[counter.ColumnIndex], out value))
                //                    {
                //                        content.AppendFormat("{0}={1:0.00},", counter.CounterName, value);
                //                        useCounter = true;
                //                    }
                //                }
                //                if (useCounter)
                //                    content.AppendFormat(" {0}\n", epoch);
                //                else
                //                {
                //                    content.Length = lineStartIndex;
                //                }
                //            }
                //        }

                //        //each group will have an ending comma which is not needed
                //        content.Replace(", ", " ");
                //        //remove last \n
                //        content.Remove(content.Length - 1, 1);
                //        //synchronous processing
                //        if (PostToInflux(influxAddress, content.ToString()))
                //            Console.Write("\r Processed {0}        ", lineCount);
                //        else
                //        {
                //            failedCount++;
                //            Console.Write("\r Line {0}, failed     ", lineCount);
                //        }
                //    }
                //    catch (Exception e)
                //    {

                //    }
                //}
                //stopwatch.Stop();
                //Debug.WriteLine("Done Sync Processing,  elapsed: {0}", stopwatch.Elapsed);
                #endregion

                Console.Write ("\n Done!! Processed{0}, failed to insert{1}", lineCount, failedCount);
            }
            catch ( Exception e )
            {
                Console.WriteLine ("\rError Processing, Exception:{0}", e.Message);
                Debug.WriteLine ("\rError Processing, Exception:{0}", e.Message);
            }
        }

        private static async Task<bool> ProcessLine(string line, IEnumerable<IGrouping<string, PerfmonCounter>> perfGourp, int minOffset, Regex pattern, HttpClient client)
        {
            StringBuilder content = new StringBuilder ();
            DateTime timeStamp;
            try
            {
                var columns = pattern.Split (line.Replace ("\"", ""));
                var columnCount = columns.Count ();

                if ( !DateTime.TryParseExact (columns[0], timeFormat, CultureInfo.InvariantCulture, DateTimeStyles.None, out timeStamp) )
                    throw new FormatException ("Couldn't parse " + columns[0] + " using format " + timeFormat + ", check -timeformat argument");
                var epoch = timeStamp.AddMinutes (minOffset).ToEpoch ();

                double value = 0.0;
                content.Clear ();
                var lineStartIndex = 0;

                foreach ( var group in perfGourp )
                {
                    foreach ( var hostGrp in group.GroupBy (p => p.Host) )
                    {
                        lineStartIndex = content.Length;
                        content.AppendFormat ("{0},Host={1} ", group.Key, hostGrp.Key);
                        var useCounter = false;
                        foreach ( var counter in hostGrp )
                        {
                            if ( !String.IsNullOrWhiteSpace (columns[counter.ColumnIndex]) && Double.TryParse (columns[counter.ColumnIndex], out value) )
                            {
                                content.AppendFormat ("{0}={1:0.00},", counter.CounterName, value);
                                useCounter = true;
                            }
                        }
                        if ( useCounter )
                            content.AppendFormat (" {0}\n", epoch);
                        else
                        {
                            content.Length = lineStartIndex;
                        }
                    }
                }

                //each group will have an ending comma which is not needed
                content.Replace (", ", " ");
                //remove last \n
                content.Remove (content.Length - 1, 1);
                //synchronous processing
                if ( await PostToInfluxAsync (client, content.ToString ()) )
                    return true;
                else
                {
                    return false;
                }
            }
            catch ( Exception e )
            {
                Debug.WriteLine (e.Message);
            }
            return false;
        }
        private static bool PostToInflux(Uri InfluxAddress, string content)
        {
            var httpWebRequest = (HttpWebRequest) WebRequest.Create (InfluxAddress);
            var proxy = WebRequest.GetSystemWebProxy ();
            proxy.Credentials = System.Net.CredentialCache.DefaultCredentials;
            httpWebRequest.Proxy = proxy;
            httpWebRequest.ContentType = "binary/octet-stream";
            httpWebRequest.Method = "POST";

            byte[] byteArray = Encoding.UTF8.GetBytes (content);
            httpWebRequest.ContentLength = byteArray.Length;

            using ( var dataStream = httpWebRequest.GetRequestStream () )
            {
                dataStream.Write (byteArray, 0, byteArray.Length);
                dataStream.Flush ();
                dataStream.Close ();
            }

            try
            {
                HttpWebResponse resp = (HttpWebResponse) httpWebRequest.GetResponse ();
                if ( resp.StatusCode == HttpStatusCode.NoContent )
                    return true;
                else
                    return false;
            }

            catch ( WebException ex )
            {
                var s = new StreamReader (ex.Response.GetResponseStream ()).ReadToEnd ();
                throw new Exception (s);
            }

            catch ( Exception ex )
            {
                //process exception here   
                return false;
            }
            return true;
        }

        private static async Task<bool> PostToInfluxAsync(HttpClient client, string content)
        {
            ByteArrayContent requestContent = new ByteArrayContent (Encoding.UTF8.GetBytes (content));
            try
            {
                HttpResponseMessage response = await client.PostAsync (client.BaseAddress, requestContent);

                if ( response.StatusCode == HttpStatusCode.NoContent )
                    return true;
                else
                    return false;
            }
            catch ( HttpRequestException e )
            {
                return false;
            }

        }
    }
}
