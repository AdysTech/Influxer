//Copyright -  Adarsha@AdysTech
//https://github.com/AdysTech/Influxer/blob/master/Influxer/Program.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading.Tasks;
using System.Net.Http;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Globalization;
using System.Net.Http.Headers;

namespace AdysTech.Influxer
{
    class Program
    {
        enum Filters
        {
            None,
            Measurement,
            Field,
            Columns
        }

        enum FileFormats
        {
            Perfmon,
            Generic
        }

        const string InfluxUrlSwitch = "-influx";
        const string InfluxDBSwitch = "-dbname";
        const string TagsSwitch = "-tags";
        const string InputFileNameSwitch = "-input";
        const string ColumnSeperatorSwitch = "-seperator";
        const string DateTimeFormatSwitch = "-timeformat";
        const string InfluxUserNameSwitch = "-uname";
        const string InfluxPwdSwitch = "-pass";
        const string FileFormatSwitch = "-format";
        const string TableNameSwitch = "-table";
        const string FilterSwitch = "-filter";
        const string ColumnsSwitch = "-columns";

        private static string influxUrl;
        private static string influxDB;
        private static string influxDBUserName;
        private static string influxDBPassword;
        private static string tags;
        private static string inputFileName;
        private static char seperator = ',';
        private static string timeFormat = "MM/dd/yyyy HH:mm:ss.fff";
        private static FileFormats fileFormat;
        private static string tableName;
        private static Regex pattern;
        private static Filters filter;
        private static string filteredColumns;

        private static char[] influxIdentifiers = new char[] { ' ', ';', '_', '(', ')', '%', '#', '.', '/', '[', ']', '{', '}', '"' };
        private static char[] whiteSpace = new char[] { '_' };

        static int Main(string[] args)
        {
            #region Command Line argument processing
            if ( args.Contains ("--help") )
            {
                Console.WriteLine ("Valid switches are");
                Console.WriteLine ("-influx <url>       :   Influx DB Url");
                Console.WriteLine ("-dbName <name>      :   Influx DB Name (will be created if not exists)");
                Console.WriteLine ("-uname <username>   :   Influx DB User name");
                Console.WriteLine ("-pass <password>    :   Influx DB Password");
                Console.WriteLine ("-tags <tags>        :   Tags to be passed with every value, key value pairs, space will be converted to _");
                Console.WriteLine ("-input <filename>   :   Input File CSV generated by PerfMon");
                Console.WriteLine ("-seperator <char>   :   Column Seperators default is ,");
                Console.WriteLine ("-timeformat <format>:   Timeformat used by PerfMon (default MM/dd/yyyy hh:mm:ss.fff)");
                Console.WriteLine ("-format <format>    :   CSV File format PerfMon(default) and Generic are supported. For generic TableName is required");
                Console.WriteLine ("-table <table name> :   Influx Table name needed for generic fomat only");
                Console.WriteLine ("-filter <filter>    :   supported:measurement, field, columns.");
                Console.WriteLine ("-columns <columns>  :   Comma seperated list of columns from input files");
                Console.WriteLine ("-filter-measurement or field is to restrict the input file to only measurements or fileds that already present in the database");
                Console.WriteLine ("-filter-columns is to restrict to only few columns from the input irrespective of existing data in database");
                Console.WriteLine ("-columns will be ignored in other cases. Replace any inline commas in columns names with a space!");
                return 0;
            }

            if ( args.Length == 0 || args.Length % 2 != 0 )
            {
                Console.WriteLine ("Command line arguments not valid, try --help to see valid ones!");
                return -1;
            }

            Dictionary<string, string> cmdArgs = new Dictionary<string, string> ();
            for ( int i = 0; i < args.Length; i += 2 )
            {
                cmdArgs.Add (args[i].ToLower (), args[i + 1]);
            }



            if ( cmdArgs.ContainsKey (InfluxUrlSwitch) )
                influxUrl = cmdArgs[InfluxUrlSwitch];
            else
                throw new Exception ("Influx DB Url is a must!!");


            if ( cmdArgs.ContainsKey (InfluxDBSwitch) )
                influxDB = cmdArgs[InfluxDBSwitch];
            else
                throw new Exception ("Influx DB name is a must!!");

            if ( cmdArgs.ContainsKey (TagsSwitch) )
                tags = cmdArgs[TagsSwitch].Replace (' ', '_');

            if ( cmdArgs.ContainsKey (TableNameSwitch) )
                tableName = cmdArgs[TableNameSwitch];

            if ( cmdArgs.ContainsKey (InputFileNameSwitch) )
            {
                try
                {
                    inputFileName = Path.GetFullPath (cmdArgs[InputFileNameSwitch]);
                }
                catch ( Exception e )
                {
                    Console.WriteLine ("Error with report file:{0},{1}", e.GetType ().Name, e.Message);
                }
            }
            else
                throw new Exception ("Input File Name is a must");

            if ( cmdArgs.ContainsKey (ColumnSeperatorSwitch) )
                seperator = cmdArgs[ColumnSeperatorSwitch][0];
            pattern = new Regex (seperator + "(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)", RegexOptions.Compiled);

            if ( cmdArgs.ContainsKey (DateTimeFormatSwitch) )
                timeFormat = cmdArgs[DateTimeFormatSwitch];

            if ( cmdArgs.ContainsKey (InfluxUserNameSwitch) )
                influxDBUserName = cmdArgs[InfluxUserNameSwitch];

            if ( cmdArgs.ContainsKey (InfluxPwdSwitch) )
                influxDBPassword = cmdArgs[InfluxPwdSwitch];

            if ( cmdArgs.ContainsKey (FileFormatSwitch) )
            {
                if ( !Enum.TryParse<FileFormats> (cmdArgs[FileFormatSwitch], true, out fileFormat) || !Enum.IsDefined (typeof (FileFormats), fileFormat) )
                {
                    Console.WriteLine ("Not supported format{0}!!", cmdArgs[FileFormatSwitch]);
                    return 1;
                }
            }
            {
                fileFormat = FileFormats.Perfmon;
            }

            if ( cmdArgs.ContainsKey (FilterSwitch) )
            {
                if ( !Enum.TryParse<Filters> (cmdArgs[FilterSwitch], true, out filter) || !Enum.IsDefined (typeof (Filters), filter) )
                {
                    Console.WriteLine ("Not supported filter:{0}!!", cmdArgs[FilterSwitch]);
                    return 1;
                }
            }
            else
            {
                filter = Filters.None;
            }

            if ( cmdArgs.ContainsKey (ColumnsSwitch) )
            {
                if ( filter != Filters.Columns )
                {
                    Console.WriteLine ("Column filtering is supported only with -filter Columns!!");
                    return 1;
                }
                if ( String.IsNullOrWhiteSpace (cmdArgs[ColumnsSwitch]) )
                {
                    Console.WriteLine ("Invalid Column filter!!");
                    return 1;
                }

                filteredColumns = cmdArgs[ColumnsSwitch];

                try
                {
                    var temp = ParsePerfMonFileHeader (filteredColumns, false);
                    if ( temp.Count == 0 )
                    {
                        Console.WriteLine ("No columns filtered!!");
                        return 1;
                    }
                }
                catch ( Exception e )
                {
                    Console.WriteLine ("Unable to parse column filters");
                    return 1;
                }
            }


            #endregion
            try
            {
                Stopwatch stopwatch = new Stopwatch ();
                stopwatch.Start ();

                HttpClientHandler handler = new HttpClientHandler ();
                handler.UseDefaultCredentials = true;
                handler.PreAuthenticate = true;
                handler.Proxy = WebRequest.DefaultWebProxy;
                WebRequest.DefaultWebProxy.Credentials = CredentialCache.DefaultNetworkCredentials;

                var client = new HttpClient (handler);
                if ( !( String.IsNullOrWhiteSpace (influxDBUserName) && String.IsNullOrWhiteSpace (influxDBPassword) ) )
                    client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue ("Basic", Convert.ToBase64String (System.Text.ASCIIEncoding.ASCII.GetBytes (string.Format ("{0}:{1}", influxDBUserName, influxDBPassword))));

                if ( !VerifyDatabaseAsync (client, influxDB).Result )
                {
                    Console.WriteLine ("Unable to create DB {0}", influxDB);
                    return -1;
                }

                var result = false;
                switch ( fileFormat )
                {
                    case FileFormats.Perfmon:
                        result = ProcessPerfMonLog (inputFileName, client).Result;
                        break;
                    case FileFormats.Generic:
                        if ( String.IsNullOrWhiteSpace (tableName) )
                            throw new ArgumentException ("Generic format needs TableName input");
                        result = ProcessGenericFile (inputFileName, tableName, client).Result;
                        break;
                }

                stopwatch.Stop ();
                if ( result )
                {
                    Console.WriteLine ("\n Finished!! Processed in {0}", stopwatch.Elapsed.ToString ());
                    return 0;
                }

            }
            catch ( AggregateException e )
            {
                Console.WriteLine (e.InnerException.Message);
                Debug.WriteLine (e.InnerException.Message);
                return -1;
            }
            return 0;
        }

        private static async Task<bool> VerifyDatabaseAsync(HttpClient client, string DBName)
        {
            var influxAddress = new Uri (influxUrl + "/query?");

            //verify DB exists, create if not
            var dbNames = await GetInfluxDBNamesAsync (client, influxAddress);
            if ( dbNames == null ) return false;

            if ( dbNames.Contains (DBName) )
                return true;
            else
            {
                if ( filter == Filters.Measurement || filter == Filters.Field )
                {
                    Console.WriteLine ("Measurement/Field filtering is not applicable for new database!!");
                    filter = Filters.None;
                }
                return await CreateInfluxDBAsync (client, DBName, influxAddress);
            }
        }

        private static async Task<List<String>> GetInfluxDBNamesAsync(HttpClient client, Uri InfluxPath)
        {
            try
            {
                var builder = new UriBuilder (InfluxPath);
                //builder.UserName = influxDBUserName;
                //builder.Password = influxDBPassword;
                builder.Query = await new FormUrlEncodedContent (new[] { 
                    new KeyValuePair<string, string>("u",influxDBUserName) ,
                    new KeyValuePair<string, string>("p", influxDBPassword) ,
                    new KeyValuePair<string, string>("q", "SHOW DATABASES") 
                    }).ReadAsStringAsync ();
                HttpResponseMessage response = await client.GetAsync (builder.Uri);

                if ( response.StatusCode == HttpStatusCode.OK )
                {
                    var content = await response.Content.ReadAsStringAsync ();
                    return Regex.Matches (content, "([a-zA-Z0-9]+)").Cast<Match> ().Select (match => match.Value).SkipWhile (p => p != "values").Skip (1).ToList ();
                }
            }
            catch ( HttpRequestException e )
            {
                return null;
            }
            return null;
        }

        private static async Task<Dictionary<string, List<String>>> GetInfluxDBStructureAsync(HttpClient client, Uri InfluxPath, string dbName)
        {
            var dbStructure = new Dictionary<string, List<string>> ();
            try
            {
                var builder = new UriBuilder (InfluxPath);
                //builder.UserName = influxDBUserName;
                //builder.Password = influxDBPassword;
                builder.Query = await new FormUrlEncodedContent (new[] { 
					new KeyValuePair<string, string>("u",influxDBUserName) ,
					new KeyValuePair<string, string>("p", influxDBPassword) ,
					new KeyValuePair<string, string>("db", dbName) ,
					new KeyValuePair<string, string>("q", "SHOW FIELD KEYS") 
					}).ReadAsStringAsync ();
                HttpResponseMessage response = await client.GetAsync (builder.Uri);

                if ( response.StatusCode == HttpStatusCode.OK )
                {
                    var content = await response.Content.ReadAsStringAsync ();
                    var values = Regex.Matches (content, "([a-zA-Z0-9_]+)").Cast<Match> ().Select (match => match.Value).ToList ();
                    string measurement;
                    //one pass loop through the entries in returned structure. Each new measurement starts with "name",measurement name, "columns","fieldKey","values",list of columns
                    //we will search for name, and once found grab measurement name, skip 3 lines, and grab column names
                    for ( int i = 0; i < values.Count; i++ )
                    {
                        if ( values[i] != "name" )
                            continue;
                        if ( values[i] == "name" )
                        {
                            if ( ++i == values.Count )
                                throw new InvalidDataException ("Invalid data returned from InfluxDB");
                            //i is incremented
                            measurement = values[i];
                            dbStructure.Add (measurement, new List<string> ());
                            for ( int j = i + 4; j < values.Count; j++ )
                            {
                                if ( values[j] == "name" )
                                {
                                    i = j - 1;
                                    break;
                                }
                                dbStructure[measurement].Add (values[j]);
                            }
                        }
                    }
                }
            }
            catch ( HttpRequestException e )
            {

            }

            return dbStructure;
        }


        private static async Task<bool> CreateInfluxDBAsync(HttpClient client, string dbName, Uri InfluxPath)
        {
            try
            {
                var builder = new UriBuilder (InfluxPath);
                //builder.UserName = influxDBUserName;
                //builder.Password = influxDBPassword;
                builder.Query = await new FormUrlEncodedContent (new[] { 
                    new KeyValuePair<string, string>("u",influxDBUserName) ,
                    new KeyValuePair<string, string>("p", influxDBPassword) ,
                    new KeyValuePair<string, string>("q", "CREATE DATABASE "+ dbName) 
                    }).ReadAsStringAsync ();
                HttpResponseMessage response = await client.GetAsync (builder.Uri);

                if ( response.StatusCode == HttpStatusCode.OK )
                {
                    var content = await response.Content.ReadAsStringAsync ();
                    return true;
                }
            }
            catch ( HttpRequestException e )
            {
                return false;
            }
            return false;
        }


        private static async Task<bool> PostToInfluxAsync(HttpClient client, Uri InfluxPath, string content)
        {
            ByteArrayContent requestContent = new ByteArrayContent (Encoding.UTF8.GetBytes (content));
            try
            {
                HttpResponseMessage response = await client.PostAsync (InfluxPath, requestContent);

                if ( response.StatusCode == HttpStatusCode.Unauthorized || response.StatusCode == HttpStatusCode.BadGateway || ( response.StatusCode == HttpStatusCode.InternalServerError && response.ReasonPhrase == "INKApi Error" ) ) //502 Connection refused
                    throw new UnauthorizedAccessException ("InfluxDB needs authentication. Check uname, pwd parameters");
                //if(response.StatusCode==HttpStatusCode.NotFound)

                else if ( response.StatusCode == HttpStatusCode.NoContent )
                    return true;
                else
                    return false;
            }
            catch ( HttpRequestException ex )
            {
                return false;
            }
            catch ( Exception e )
            {
                if ( e is UnauthorizedAccessException )
                    throw e;
                return false;
            }

        }

        private static async Task<bool> ProcessPerfMonLog(string InputFileName, HttpClient client)
        {

            try
            {
                int minOffset = 0;
                var lineCount = 0;
                var failedCount = 0;
                StringBuilder content = new StringBuilder ();

                Stopwatch stopwatch = new Stopwatch ();
                stopwatch.Start ();

                var influxAddress = new Uri (influxUrl + "/write?db=" + influxDB + "&precision=s");


                var firstLine = File.ReadLines (InputFileName).FirstOrDefault ();

                var firstCol = firstLine.Substring (0, firstLine.IndexOf (','));
                if ( !firstCol.Contains ("PDH-CSV") )
                    throw new Exception ("Input file is not a Standard Perfmon csv file");
                var x = Regex.Matches (firstCol, "([-0-9]+)");
                if ( x.Count > 0 )
                    minOffset = int.Parse (x[3].ToString ());

                //get the column headers
                List<PerfmonCounter> pecrfCounters;
                try
                {
                    pecrfCounters = ParsePerfMonFileHeader (firstLine);
                }
                catch ( Exception ex )
                {
                    throw new InvalidDataException ("Unable to parse file headers", ex);
                }

                var filterColumns = ParsePerfMonFileHeader (filteredColumns, false);

                Dictionary<string, List<string>> dbStructure;
                IEnumerable<IGrouping<string, PerfmonCounter>> perfGroup;
                if ( filter != Filters.None )
                {
                    dbStructure = await GetInfluxDBStructureAsync (client, new Uri (influxUrl + "/query?"), influxDB);
                    perfGroup = FilterPerfmonLogColumns (pecrfCounters, filterColumns, dbStructure).GroupBy (p => p.PerformanceObject);
                }
                else
                {
                    perfGroup = pecrfCounters.GroupBy (p => p.PerformanceObject);
                }

                //Parallel.ForEach (File.ReadLines (inputFileName).Skip (1), (string line) =>
                foreach ( var line in File.ReadLines (InputFileName).Skip (1) )
                {
                    try
                    {
                        if ( !await ProcessPerfmonLogLine (line, perfGroup, minOffset, pattern, client, influxAddress) )
                            failedCount++;

                        lineCount++;

                        if ( failedCount > 0 )
                            Console.Write ("\r{0} Processed {1}, Failed - {2}                        ", stopwatch.Elapsed.ToString (@"hh\:mm\:ss"), lineCount, failedCount);
                        else
                            Console.Write ("\r{0} Processed {1}                          ", stopwatch.Elapsed.ToString (@"hh\:mm\:ss"), lineCount);
                    }
                    catch ( Exception e )
                    {
                        Console.WriteLine (e.InnerException.Message);
                        Debug.WriteLine (e.InnerException.Message);
                        break;
                    }
                }


                stopwatch.Stop ();
                //Debug.WriteLine("Done Async Processing, Time elapsed: {0}", stopwatch.Elapsed);

                lineCount = 0;
                pecrfCounters.Clear ();


                Console.Write ("\n Done!! Processed{0}, failed to insert{1}", lineCount, failedCount);
            }
            catch ( Exception e )
            {
                Console.WriteLine ("\rError Processing, Exception:{0}", e.Message);
                Debug.WriteLine ("\rError Processing, Exception:{0}", e.Message);
                return false;
            }
            return true;
        }

        private static List<PerfmonCounter> ParsePerfMonFileHeader(string headerLine, bool quoted = true)
        {
            List<PerfmonCounter> perfCounters = new List<PerfmonCounter> ();
            if ( String.IsNullOrWhiteSpace (headerLine) ) return perfCounters;
            var columns = pattern.Split (headerLine);
            var column = 1;

            perfCounters.AddRange (columns.Skip (quoted ? 1 : 0).Where (s => quoted ? s.StartsWith ("\"\\") : s.StartsWith ("\\")).Select (p =>
                    p.Replace (influxIdentifiers, "_").Split ('\\')).Select (p =>
                        new PerfmonCounter ()
                        {
                            ColumnIndex = column++,
                            Host = p[2].Trim (whiteSpace),
                            PerformanceObject = p[3].Trim (whiteSpace),
                            CounterName = p[4].Trim (whiteSpace)
                        }));
            return perfCounters;
        }

        private static List<PerfmonCounter> FilterPerfmonLogColumns(List<PerfmonCounter> columns, List<PerfmonCounter> filterColumns, Dictionary<string, List<string>> dbStructure)
        {
            switch ( filter )
            {
                case Filters.Measurement:
                    return columns.Where (p => dbStructure.ContainsKey (p.PerformanceObject)).ToList ();
                case Filters.Field:
                    return columns.Where (p => dbStructure[p.PerformanceObject].Contains (p.CounterName)).ToList ();
                case Filters.Columns:
                    return columns.Where (p => filterColumns.Any (f => p.PerformanceObject == f.PerformanceObject && p.CounterName == f.CounterName)).ToList ();
            }
            return columns;
        }

        private static async Task<bool> ProcessPerfmonLogLine(string line, IEnumerable<IGrouping<string, PerfmonCounter>> perfGroup, int minOffset, Regex pattern, HttpClient client, Uri InfluxPath)
        {
            StringBuilder content = new StringBuilder ();
            DateTime timeStamp;
            try
            {
                var columns = pattern.Split (line.Replace ("\"", ""));
                var columnCount = columns.Count ();

                if ( !DateTime.TryParseExact (columns[0], timeFormat, CultureInfo.InvariantCulture, DateTimeStyles.None, out timeStamp) )
                    throw new FormatException ("Couldn't parse " + columns[0] + " using format " + timeFormat + ", check -timeformat argument");
                var epoch = timeStamp.AddMinutes (minOffset).ToEpoch ();

                double value = 0.0;
                content.Clear ();
                var lineStartIndex = 0;

                foreach ( var group in perfGroup )
                {
                    foreach ( var hostGrp in group.GroupBy (p => p.Host) )
                    {
                        lineStartIndex = content.Length;
                        content.AppendFormat ("{0},Host={1}", group.Key, hostGrp.Key);

                        if ( tags != null )
                            content.AppendFormat (",{0} ", tags);
                        else
                            content.Append (" ");

                        var useCounter = false;

                        foreach ( var counter in hostGrp )
                        {
                            if ( !String.IsNullOrWhiteSpace (columns[counter.ColumnIndex]) && Double.TryParse (columns[counter.ColumnIndex], out value) )
                            {
                                content.AppendFormat ("{0}={1:0.00},", counter.CounterName, value);
                                useCounter = true;

                            }
                        }

                        if ( useCounter )
                            content.AppendFormat (" {0}\n", epoch);
                        else
                        {
                            content.Length = lineStartIndex;
                        }
                    }
                }

                //each group will have an ending comma which is not needed
                content.Replace (", ", " ");
                //remove last \n
                content.Remove (content.Length - 1, 1);
                //synchronous processing
                if ( await PostToInfluxAsync (client, InfluxPath, content.ToString ()) )
                    return true;
                else
                {
                    return false;
                }
            }
            catch ( UnauthorizedAccessException e )
            {
                throw e;
            }
            catch ( Exception e )
            {
                Debug.WriteLine (e.Message);
            }
            return false;
        }

        private static async Task<bool> ProcessGenericFile(string InputFileName, string tableName, HttpClient client)
        {
            try
            {
                StringBuilder content = new StringBuilder ();
                var lineCount = 0;
                var failedCount = 0;

                var influxAddress = new Uri (influxUrl + "/write?db=" + influxDB + "&precision=s");
                client.BaseAddress = influxAddress;
                List<string> columnHeaders = new List<string> ();

                var firstLine = File.ReadLines (InputFileName).FirstOrDefault ();
                columnHeaders.AddRange (pattern.Split (firstLine.Replace ("\"", "")));

                //Parallel.ForEach (File.ReadLines (inputFileName).Skip (1), (string line) =>
                foreach ( var line in File.ReadLines (InputFileName).Skip (1) )
                {
                    try
                    {
                        if ( !await ProcessGenericLine (line, columnHeaders, pattern, client, influxAddress) )
                            failedCount++;

                        lineCount++;

                        if ( failedCount > 0 )
                            Console.Write ("\r Processed {0}, Failed - {1}                        ", lineCount, failedCount);
                        else
                            Console.Write ("\r Processed {0}                          ", lineCount);

                    }
                    catch ( Exception e )
                    {
                        Console.WriteLine (e.InnerException.Message);
                        Debug.WriteLine (e.InnerException.Message);
                        break;
                    }
                }
                lineCount = 0;
                Console.Write ("\n Done!! Processed{0}, failed to insert{1}", lineCount, failedCount);
            }
            catch ( Exception e )
            {
                Console.WriteLine ("\rError Processing, Exception:{0}", e.Message);
                Debug.WriteLine ("\rError Processing, Exception:{0}", e.Message);
                return false;
            }
            return true;
        }

        private async static Task<bool> ProcessGenericLine(string line, List<string> columnHeaders, Regex pattern, HttpClient client, Uri InfluxPath)
        {
            StringBuilder content = new StringBuilder ();
            DateTime timeStamp;
            try
            {
                var columns = pattern.Split (line.Replace ("\"", ""));
                var columnCount = columns.Count ();

                if ( !DateTime.TryParseExact (columns[0], timeFormat, CultureInfo.InvariantCulture, DateTimeStyles.None, out timeStamp) )
                    throw new FormatException ("Couldn't parse " + columns[0] + " using format " + timeFormat + ", check -timeformat argument");
                var epoch = timeStamp.ToEpoch ();

                double value = 0.0;
                content.AppendFormat ("{0}", tableName);
                if ( tags != null )
                    content.AppendFormat (",{0} ", tags);
                else
                    content.Append (" ");

                for ( var i = 1; i < columnCount; i++ )
                {
                    if ( Double.TryParse (columns[i], out value) )
                        content.AppendFormat ("{0}={1:0.00},", columnHeaders[i], value);
                }

                content.AppendFormat (" {0}\n", epoch);
                //each group will have an ending comma which is not needed
                content.Replace (", ", " ");

                //remove last \n
                content.Remove (content.Length - 1, 1);
                //synchronous processing
                if ( await PostToInfluxAsync (client, InfluxPath, content.ToString ()) )
                    return true;
                else
                {
                    return false;
                }
            }
            catch ( UnauthorizedAccessException e )
            {
                throw e;
            }
            catch ( Exception e )
            {
                Debug.WriteLine (e.Message);
            }
            return false;
        }
    }
}
