//Copyright -  Adarsha@AdysTech
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading.Tasks;
using System.Net.Http;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Globalization;
using System.Net.Http.Headers;

namespace AdysTech.Influxer
{
    class Program
    {
        const string InfluxUrlSwitch = "-influx";
        const string InfluxDBSwitch = "-dbname";
        const string TagsSwitch = "-tags";
        const string InputFileNameSwitch = "-input";
        const string ColumnSeperatorSwitch = "-seperator";
        const string DateTimeFormatSwitch = "-timeformat";
        const string InfluxUserNameSwitch = "-uname";
        const string InfluxPwdSwitch = "-pass";
        const string FileFormatSwitch = "-format";
        const string TableNameSwitch = "-table";

        private static string influxUrl;
        private static string influxDB;
        private static string influxDBUserName;
        private static string influxDBPassword;
        private static string tags;
        private static string inputFileName;
        private static char seperator = ',';
        private static string timeFormat = "MM/dd/yyyy HH:mm:ss.fff";
        private static string fileFormat = "perfmon";
        private static string tableName;
        private static Regex pattern;

        static int Main(string[] args)
        {
            #region Command Line argument processing
            if ( args.Contains ("--help") )
            {
                Console.WriteLine ("Valid switches are");
                Console.WriteLine ("-influx <url>       :   Influx DB Url");
                Console.WriteLine ("-dbName <name>      :   Influx DB Name (will be created if not exists)");
                Console.WriteLine ("-uname <username>   :   Influx DB User name");
                Console.WriteLine ("-pass <password>    :   Influx DB Password");
                Console.WriteLine ("-tags <tags>        :   Tags to be passed with every value, key value pairs, space will be converted to _");
                Console.WriteLine ("-input <filename>   :   Input File CSV generated by PerfMon");
                Console.WriteLine ("-seperator <char>   :   Column Seperators default is ,");
                Console.WriteLine ("-timeformat <format>:   Timeformat used by PerfMon (default MM/dd/yyyy hh:mm:ss.fff)");
                Console.WriteLine ("-format <format>    :   CSV File format PerfMon(default) and Generic are supported. For generic TableName is required");
                Console.WriteLine ("-table <table name> :   Influx Table name needed for generic fomat only");
                return 0;
            }

            if ( args.Length == 0 || args.Length % 2 != 0 )
            {
                Console.WriteLine ("Command line arguments not valid, try --help to see valid ones!");
                return -1;
            }

            Dictionary<string, string> cmdArgs = new Dictionary<string, string> ();
            for ( int i = 0; i < args.Length; i += 2 )
            {
                cmdArgs.Add (args[i].ToLower (), args[i + 1]);
            }



            if ( cmdArgs.ContainsKey (InfluxUrlSwitch) )
                influxUrl = cmdArgs[InfluxUrlSwitch];
            else
                throw new Exception ("Influx DB Url is a must!!");


            if ( cmdArgs.ContainsKey (InfluxDBSwitch) )
                influxDB = cmdArgs[InfluxDBSwitch];
            else
                throw new Exception ("Influx DB name is a must!!");

            if ( cmdArgs.ContainsKey (TagsSwitch) )
                tags = cmdArgs[TagsSwitch].Replace (' ', '_');


            if ( cmdArgs.ContainsKey (InputFileNameSwitch) )
            {
                try
                {
                    inputFileName = Path.GetFullPath (cmdArgs[InputFileNameSwitch]);
                }
                catch ( Exception e )
                {
                    Console.WriteLine ("Error with report file:{0},{1}", e.GetType ().Name, e.Message);
                }
            }
            else
                throw new Exception ("Input File Name is a must");

            if ( cmdArgs.ContainsKey (ColumnSeperatorSwitch) )
                seperator = cmdArgs[ColumnSeperatorSwitch][0];
            pattern = new Regex (seperator + "(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)", RegexOptions.Compiled);

            if ( cmdArgs.ContainsKey (DateTimeFormatSwitch) )
                timeFormat = cmdArgs[DateTimeFormatSwitch];

            if ( cmdArgs.ContainsKey (InfluxUserNameSwitch) )
                influxDBUserName = cmdArgs[InfluxUserNameSwitch];

            if ( cmdArgs.ContainsKey (InfluxPwdSwitch) )
                influxDBPassword = cmdArgs[InfluxPwdSwitch];

            if ( cmdArgs.ContainsKey (FileFormatSwitch) )
            {
                fileFormat = cmdArgs[FileFormatSwitch].ToLower ();
                if ( !new[] { "perfmon", "generic" }.Contains (fileFormat) )
                {
                    Console.WriteLine ("Not supported format{0}!!", fileFormat);
                    return 1;
                }
            }

            if ( cmdArgs.ContainsKey (TableNameSwitch) )
                tableName = cmdArgs[TableNameSwitch];

            #endregion
            try
            {
                HttpClientHandler handler = new HttpClientHandler ();
                handler.UseDefaultCredentials = true;
                handler.PreAuthenticate = true;
                handler.Proxy = WebRequest.DefaultWebProxy;
                WebRequest.DefaultWebProxy.Credentials = CredentialCache.DefaultNetworkCredentials;

                var client = new HttpClient (handler);
                if ( !( String.IsNullOrWhiteSpace (influxDBUserName) && String.IsNullOrWhiteSpace (influxDBPassword) ) )
                    client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue ("Basic", Convert.ToBase64String (System.Text.ASCIIEncoding.ASCII.GetBytes (string.Format ("{0}:{1}", influxDBUserName, influxDBPassword))));

                if ( !VerifyDatabase (client, influxDB).Result )
                {
                    Console.WriteLine ("Unable to create DB {0}", influxDB);
                    return -1;
                }

                var result = false;
                switch ( fileFormat )
                {
                    case "perfmon":
                        result = ProcessPerfMonLog (inputFileName, client).Result;
                        break;
                    case "generic":
                        if ( String.IsNullOrWhiteSpace (tableName) )
                            throw new ArgumentException ("Generic format needs TableName input");
                        result = ProcessGenericFile (inputFileName, tableName, client).Result;
                        break;
                }

                if ( result )
                {
                    Console.WriteLine ("Finished!!");
                    return 0;
                }

            }
            catch ( AggregateException e )
            {
                Console.WriteLine (e.InnerException.Message);
                Debug.WriteLine (e.InnerException.Message);
                return -1;
            }
            return 0;
        }

        private static async Task<bool> VerifyDatabase(HttpClient client, string DBName)
        {
            var influxAddress = new Uri (influxUrl + "/query?");

            //verify DB exists, create if not
            var dbNames = await GetInfluxDBNamesAsync (client, influxAddress);
            if ( dbNames == null ) return false;

            if ( dbNames.Contains (DBName) )
                return true;
            else
            {
                return await CreateInfluxDBAsync (client, DBName, influxAddress);
            }
        }

        private static async Task<List<String>> GetInfluxDBNamesAsync(HttpClient client, Uri InfluxPath)
        {
            try
            {
                var builder = new UriBuilder (InfluxPath);
                //builder.UserName = influxDBUserName;
                //builder.Password = influxDBPassword;
                builder.Query = await new FormUrlEncodedContent (new[] { 
                    new KeyValuePair<string, string>("u",influxDBUserName) ,
                    new KeyValuePair<string, string>("p", influxDBPassword) ,
                    new KeyValuePair<string, string>("q", "SHOW DATABASES") 
                    }).ReadAsStringAsync ();
                HttpResponseMessage response = await client.GetAsync (builder.Uri);

                if ( response.StatusCode == HttpStatusCode.OK )
                {
                    var content = await response.Content.ReadAsStringAsync ();
                    return Regex.Matches (content, "([a-zA-Z0-9]+)").Cast<Match> ().Select (match => match.Value).SkipWhile (p => p != "values").Skip (1).ToList ();
                }
            }
            catch ( HttpRequestException e )
            {
                return null;
            }
            return null;
        }

        private static async Task<bool> CreateInfluxDBAsync(HttpClient client, string dbName, Uri InfluxPath)
        {
            try
            {
                var builder = new UriBuilder (InfluxPath);
                //builder.UserName = influxDBUserName;
                //builder.Password = influxDBPassword;
                builder.Query = await new FormUrlEncodedContent (new[] { 
                    new KeyValuePair<string, string>("u",influxDBUserName) ,
                    new KeyValuePair<string, string>("p", influxDBPassword) ,
                    new KeyValuePair<string, string>("q", "CREATE DATABASE "+dbName) 
                    }).ReadAsStringAsync ();
                HttpResponseMessage response = await client.GetAsync (builder.Uri);

                if ( response.StatusCode == HttpStatusCode.OK )
                {
                    var content = await response.Content.ReadAsStringAsync ();
                    return true;
                }
            }
            catch ( HttpRequestException e )
            {
                return false;
            }
            return false;
        }


        private static async Task<bool> PostToInfluxAsync(HttpClient client, Uri InfluxPath, string content)
        {
            ByteArrayContent requestContent = new ByteArrayContent (Encoding.UTF8.GetBytes (content));
            try
            {
                HttpResponseMessage response = await client.PostAsync (InfluxPath, requestContent);

                if ( response.StatusCode == HttpStatusCode.Unauthorized || response.StatusCode == HttpStatusCode.BadGateway || ( response.StatusCode == HttpStatusCode.InternalServerError && response.ReasonPhrase == "INKApi Error" ) ) //502 Connection refused
                    throw new UnauthorizedAccessException ("InfluxDB needs authentication. Check uname, pwd parameters");
                //if(response.StatusCode==HttpStatusCode.NotFound)

                else if ( response.StatusCode == HttpStatusCode.NoContent )
                    return true;
                else
                    return false;
            }
            catch ( HttpRequestException e )
            {
                return false;
            }
            catch ( Exception e )
            {
                if ( e is UnauthorizedAccessException )
                    throw e;
                return false;
            }

        }

        private static async Task<bool> ProcessPerfMonLog(string InputFileName, HttpClient client)
        {

            try
            {
                int minOffset = 0;
                var lineCount = 0;
                var failedCount = 0;
                StringBuilder content = new StringBuilder ();

                //Stopwatch stopwatch = new Stopwatch();
                //stopwatch.Start();

                var influxAddress = new Uri (influxUrl + "/write?db=" + influxDB + "&precision=s");

                List<PerfmonCounter> pecrfCounters = new List<PerfmonCounter> ();
                IEnumerable<IGrouping<string, PerfmonCounter>> perfGourp = null;


                var firstLine = File.ReadLines (InputFileName).FirstOrDefault ();
                var columns = pattern.Split (firstLine.Replace ("\"", ""));

                if ( !columns[0].Contains ("PDH-CSV") )
                    throw new Exception ("Input file is not a Standard Perfmon csv file");
                var x = Regex.Matches (columns[0], "([-0-9]+)");
                if ( x.Count > 0 )
                    minOffset = int.Parse (x[3].ToString ());
                //get the column headers
               var column = 1;
               var influxIdentifiers = new char[]{' ',';','_','(',')','%'};
               var whiteSpace = new char[]{'_'};
               pecrfCounters.AddRange (columns.Skip (1).Where (s => s.StartsWith ("\\")).Select (p => 
                		p.Replace (influxIdentifiers, "_").Split ('\\')).Select (p => 
                			new PerfmonCounter () 
                			{ 
                				ColumnIndex = column++, 
                				Host = p[2].Trim(whiteSpace), 
                				PerformanceObject = p[3].Trim(whiteSpace), 
                				CounterName = p[4].Trim(whiteSpace) 
                			}));
                perfGourp = pecrfCounters.GroupBy (p => p.PerformanceObject);

                //Parallel.ForEach (File.ReadLines (inputFileName).Skip (1), (string line) =>
                foreach ( var line in File.ReadLines (InputFileName).Skip (1) )
                {
                    try
                    {
                        if ( await ProcessPerfmonLogLine (line, perfGourp, minOffset, pattern, client, influxAddress) )
                        {
                            lineCount++;
                            Console.Write ("\r Processed {0}                          ", lineCount);
                        }
                        else
                        {
                            failedCount++; lineCount++;
                            Console.Write ("\r Processed {0}, Failed - {1}                        ", lineCount, failedCount);
                        }
                    }
                    catch ( Exception e )
                    {
                        Console.WriteLine (e.InnerException.Message);
                        Debug.WriteLine (e.InnerException.Message);
                        break;
                    }
                }


                //stopwatch.Stop();
                //Debug.WriteLine("Done Async Processing, Time elapsed: {0}", stopwatch.Elapsed);

                lineCount = 0;
                pecrfCounters.Clear ();


                Console.Write ("\n Done!! Processed{0}, failed to insert{1}", lineCount, failedCount);
            }
            catch ( Exception e )
            {
                Console.WriteLine ("\rError Processing, Exception:{0}", e.Message);
                Debug.WriteLine ("\rError Processing, Exception:{0}", e.Message);
                return false;
            }
            return true;
        }

        private static async Task<bool> ProcessPerfmonLogLine(string line, IEnumerable<IGrouping<string, PerfmonCounter>> perfGourp, int minOffset, Regex pattern, HttpClient client, Uri InfluxPath)
        {
            StringBuilder content = new StringBuilder ();
            DateTime timeStamp;
            try
            {
                var columns = pattern.Split (line.Replace ("\"", ""));
                var columnCount = columns.Count ();

                if ( !DateTime.TryParseExact (columns[0], timeFormat, CultureInfo.InvariantCulture, DateTimeStyles.None, out timeStamp) )
                    throw new FormatException ("Couldn't parse " + columns[0] + " using format " + timeFormat + ", check -timeformat argument");
                var epoch = timeStamp.AddMinutes (minOffset).ToEpoch ();

                double value = 0.0;
                content.Clear ();
                var lineStartIndex = 0;

                foreach ( var group in perfGourp )
                {
                    foreach ( var hostGrp in group.GroupBy (p => p.Host) )
                    {
                        lineStartIndex = content.Length;
                        content.AppendFormat ("{0},Host={1}", group.Key, hostGrp.Key);
                        if ( tags != null )
                            content.AppendFormat (",{0} ", tags);
                        else
                            content.Append (" ");

                        var useCounter = false;
                        foreach ( var counter in hostGrp )
                        {
                            if ( !String.IsNullOrWhiteSpace (columns[counter.ColumnIndex]) && Double.TryParse (columns[counter.ColumnIndex], out value) )
                            {
                                content.AppendFormat ("{0}={1:0.00},", counter.CounterName, value);
                                useCounter = true;
                            }
                        }
                        if ( useCounter )
                            content.AppendFormat (" {0}\n", epoch);
                        else
                        {
                            content.Length = lineStartIndex;
                        }
                    }
                }

                //each group will have an ending comma which is not needed
                content.Replace (", ", " ");
                //remove last \n
                content.Remove (content.Length - 1, 1);
                //synchronous processing
                if ( await PostToInfluxAsync (client, InfluxPath, content.ToString ()) )
                    return true;
                else
                {
                    return false;
                }
            }
            catch ( UnauthorizedAccessException e )
            {
                throw e;
            }
            catch ( Exception e )
            {
                Debug.WriteLine (e.Message);
            }
            return false;
        }

        private static async Task<bool> ProcessGenericFile(string InputFileName, string tableName, HttpClient client)
        {
            try
            {
                StringBuilder content = new StringBuilder ();
                var lineCount = 0;
                var failedCount = 0;

                var influxAddress = new Uri (influxUrl + "/write?db=" + influxDB + "&precision=s");
                client.BaseAddress = influxAddress;
                List<string> columnHeaders = new List<string> ();

                var firstLine = File.ReadLines (InputFileName).FirstOrDefault ();
                columnHeaders.AddRange (pattern.Split (firstLine.Replace ("\"", "")));

                //Parallel.ForEach (File.ReadLines (inputFileName).Skip (1), (string line) =>
                foreach ( var line in File.ReadLines (InputFileName).Skip (1) )
                {
                    try
                    {
                        if ( await ProcessGenericLine (line, columnHeaders, pattern, client, influxAddress) )
                        {
                            lineCount++;
                            Console.Write ("\r Processed {0}                          ", lineCount);
                        }
                        else
                        {
                            failedCount++; lineCount++;
                            Console.Write ("\r Processed {0}, Failed - {1}                        ", lineCount, failedCount);
                        }
                    }
                    catch ( Exception e )
                    {
                        Console.WriteLine (e.InnerException.Message);
                        Debug.WriteLine (e.InnerException.Message);
                        break;
                    }
                }
                lineCount = 0;
                Console.Write ("\n Done!! Processed{0}, failed to insert{1}", lineCount, failedCount);
            }
            catch ( Exception e )
            {
                Console.WriteLine ("\rError Processing, Exception:{0}", e.Message);
                Debug.WriteLine ("\rError Processing, Exception:{0}", e.Message);
                return false;
            }
            return true;
        }

        private async static Task<bool> ProcessGenericLine(string line, List<string> columnHeaders, Regex pattern, HttpClient client, Uri InfluxPath)
        {
            StringBuilder content = new StringBuilder ();
            DateTime timeStamp;
            try
            {
                var columns = pattern.Split (line.Replace ("\"", ""));
                var columnCount = columns.Count ();

                if ( !DateTime.TryParseExact (columns[0], timeFormat, CultureInfo.InvariantCulture, DateTimeStyles.None, out timeStamp) )
                    throw new FormatException ("Couldn't parse " + columns[0] + " using format " + timeFormat + ", check -timeformat argument");
                var epoch = timeStamp.ToEpoch ();

                double value = 0.0;
                content.AppendFormat ("{0}", tableName);
                if ( tags != null )
                    content.AppendFormat (",{0} ", tags);
                else
                    content.Append (" ");

                for ( var i = 1; i < columnCount; i++ )
                {
                    if ( Double.TryParse (columns[i], out value) )
                        content.AppendFormat ("{0}={1:0.00},", columnHeaders[i], value);
                }

                content.AppendFormat (" {0}\n", epoch);
                //each group will have an ending comma which is not needed
                content.Replace (", ", " ");

                //remove last \n
                content.Remove (content.Length - 1, 1);
                //synchronous processing
                if ( await PostToInfluxAsync (client, InfluxPath, content.ToString ()) )
                    return true;
                else
                {
                    return false;
                }
            }
            catch ( UnauthorizedAccessException e )
            {
                throw e;
            }
            catch ( Exception e )
            {
                Debug.WriteLine (e.Message);
            }
            return false;
        }
    }
}
